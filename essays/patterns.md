---
layout: essay
type: essay
title: "Give Design Patterns A Try"
# All dates must be YYYY-MM-DD format!
date: 2025-04-24
published: true
labels:
  - Software Engineering
  - Design Patterns
---

<img width="400px" class="rounded float-start pe-4" src="../img/pass.jpg">

## Why Design Patterns?

In anything, having some form of direction is crucial to one's success. Planning out how to accomplish a goal, strategizing on how to solve a problem, and streamlining existing processes are all ways in which people find success and get results. These are all concepts you learn and become better at over time in regards to various challenges in life. Design patterns in software engineering are examples of these concepts in effect. They allow you to tackle different problems in smarter and more efficient ways. Your brain grows from each experience of coding so that you can become a more skilled programmer. This is what design patterns allow you to do. 

## My Favorites

While there are many design patterns that I use to build efficient and robust code, some stand out as being particularly consistent in how frequently applicable they are. The **Singleton Design Pattern** makes my code much cleaner and easier to understand due to much of it being centralized in one location and being easily accessible. The **Builder Method Deisgn Pattern** allows me greater flexiblity in creating mutiple variations of the same type of object. Instead of cramming every attribute into one constructor and having to address every note for each object, I can go about it in a more intelligent way. By breaking up the process of object creation, I can pick and choose how I want to specifically create a particular object. The **Decorator Method Design Pattern** works in a similar way. When I might need to store multiple states of an object from various points in time, I take advantage of the **Memento Design Pattern**.

## Conclusion

Design Patterns are essential in software engineering due to the structure that they can give to the code or program. Like algorithms, they're solutions to problems that many have faced before making them refined and passed down for each new programmer to use.
